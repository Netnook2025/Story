import React, { useState, useEffect, useRef, useCallback } from 'react';

// Main App component
const App = () => {
    // State to store the story scenes (text and visual hints)
    const [storyScenes, setStoryScenes] = useState([]);
    // State to track the current scene being displayed
    const [currentSceneIndex, setCurrentSceneIndex] = useState(0);
    // State to manage loading status during story generation
    const [isLoading, setIsLoading] = useState(false);
    // State to control video playback (simulated)
    const [isPlaying, setIsPlaying] = useState(false);
    // State to store any error messages
    const [error, setError] = useState(null);
    // State for scene progression bar
    const [sceneProgress, setSceneProgress] = useState(0);

    // Ref for the interval timer to control scene progression
    const sceneIntervalRef = useRef(null);
    // Ref for the progress bar animation frame
    const progressAnimationRef = useRef(null);
    // Ref for the last timestamp for progress bar animation
    const lastTimestampRef = useRef(0);
    // Ref for the scene content element to capture as image
    const sceneContentRef = useRef(null);

    // Constants for scene duration
    const SCENE_DURATION_SECONDS = 5; // Each scene lasts 5 seconds
    const SCENE_DURATION_MS = SCENE_DURATION_SECONDS * 1000; // 5000 milliseconds

    // Function to generate the story and visual hints using the LLM
    const generateStoryVideo = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        setStoryScenes([]); // Clear previous story
        setCurrentSceneIndex(0); // Reset scene index
        setSceneProgress(0); // Reset progress
        setIsPlaying(false); // Stop playing initially

        // LLM prompt to generate a children's story with visual hints in JSON format
        const prompt = `
        Ø¥Ù†Ø´Ø§Ø¡ Ù‚ØµØ© Ø£Ø·ÙØ§Ù„ Ù‚ØµÙŠØ±Ø© (3-5 Ø¯Ù‚Ø§Ø¦Ù‚ Ø¹Ù†Ø¯ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© Ø¨ØµÙˆØª Ø¹Ø§Ù„Ù) Ø­ÙˆÙ„ Ø­ÙŠÙˆØ§Ù† ÙˆØ¯ÙˆØ¯ ÙŠØ°Ù‡Ø¨ ÙÙŠ Ù…ØºØ§Ù…Ø±Ø© ØµØºÙŠØ±Ø© Ù„Ø§ÙƒØªØ´Ø§Ù Ø´ÙŠØ¡ Ø¬Ø¯ÙŠØ¯.
        ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ù‚ØµØ© Ù…Ù‚Ø³Ù…Ø© Ø¥Ù„Ù‰ 5-7 ÙÙ‚Ø±Ø§Øª.
        Ù„ÙƒÙ„ ÙÙ‚Ø±Ø©ØŒ Ø§Ù‚ØªØ±Ø­ ØªÙ„Ù…ÙŠØ­Ù‹Ø§ Ù…Ø±Ø¦ÙŠÙ‹Ø§ Ø¨Ø³ÙŠØ·Ù‹Ø§ (Ù…Ø«Ù„: 'ØµÙˆØ±Ø© Ù„Ø£Ø±Ù†Ø¨ ÙŠÙ„Ø¹Ø¨ ÙÙŠ Ø­Ø¯ÙŠÙ‚Ø©' Ø£Ùˆ 'Ø±Ø³ÙˆÙ… Ù…ØªØ­Ø±ÙƒØ© Ù„Ø«Ø¹Ù„Ø¨ ÙŠØ®Ø·Ø·' Ø£Ùˆ 'Ø±Ù…Ø² ØªØ¹Ø¨ÙŠØ±ÙŠ Ù„Ø´Ù…Ø³ Ù…Ø´Ø±Ù‚Ø©').
        ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙ…ÙƒÙ† ØªÙ…Ø«ÙŠÙ„ Ø§Ù„Ù€ 'visualHint' Ø¨Ø±Ù…ÙˆØ² ØªØ¹Ø¨ÙŠØ±ÙŠØ© Ø£Ùˆ Ø±Ø³ÙˆÙ… SVG Ø¨Ø³ÙŠØ·Ø© Ø¬Ø¯Ø§Ù‹ØŒ Ø£Ùˆ ÙˆØµÙ Ù†ØµÙŠ ÙˆØ§Ø¶Ø­.
        Ù‚Ù… Ø¨ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ ÙƒÙƒØ§Ø¦Ù† JSONØŒ Ø­ÙŠØ« ÙŠÙƒÙˆÙ† ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ Ù…ØµÙÙˆÙØ© 'scenes' Ø¹Ø¨Ø§Ø±Ø© Ø¹Ù† ÙƒØ§Ø¦Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ 'text' (Ù†Øµ Ø§Ù„ÙÙ‚Ø±Ø©) Ùˆ 'visualHint' (ØªÙ„Ù…ÙŠØ­ Ù…Ø±Ø¦ÙŠ).
        Ù…Ø«Ø§Ù„ Ù„Ù„ØªÙ†Ø³ÙŠÙ‚:
        {
          "scenes": [
            {
              "text": "ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø£Ø±Ù†Ø¨ ØµØºÙŠØ± ÙŠØ¯Ø¹Ù‰ Ø¨Ø§Ù†ÙŠØŒ ÙŠØ¹ÙŠØ´ ÙÙŠ Ø­Ù‚Ù„ Ø£Ø®Ø¶Ø± ÙˆØ§Ø³Ø¹.",
              "visualHint": "ğŸ° Ø­Ù‚Ù„ Ø£Ø®Ø¶Ø± ÙˆØ§Ø³Ø¹"
            },
            {
              "text": "ÙÙŠ Ø£Ø­Ø¯ Ø§Ù„Ø£ÙŠØ§Ù…ØŒ Ù‚Ø±Ø± Ø¨Ø§Ù†ÙŠ Ø§Ø³ØªÙƒØ´Ø§Ù Ù…Ø§ ÙˆØ±Ø§Ø¡ Ø§Ù„ØªÙ„ Ø§Ù„ÙƒØ¨ÙŠØ±.",
              "visualHint": "ğŸï¸ Ø£Ø±Ù†Ø¨ ÙŠØ³ØªÙƒØ´Ù ØªÙ„Ø§Ù‹"
            }
          ]
        }
        `;

        try {
            const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = {
                contents: chatHistory,
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "scenes": {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        "text": { "type": "STRING" },
                                        "visualHint": { "type": "STRING" }
                                    },
                                    "propertyOrdering": ["text", "visualHint"]
                                }
                            }
                        },
                        "propertyOrdering": ["scenes"]
                    }
                }
            };

            const apiKey = ""; // Canvas will provide this.
            // Using the correct model for JSON generation as per instructions
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API request failed: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                const jsonText = result.candidates[0].content.parts[0].text;
                const parsedData = JSON.parse(jsonText);
                if (parsedData && parsedData.scenes && Array.isArray(parsedData.scenes)) {
                    setStoryScenes(parsedData.scenes);
                    setIsPlaying(true); // Start playing immediately after generation
                } else {
                    setError("ÙØ´Ù„ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ù…Ø´Ø§Ù‡Ø¯ Ø§Ù„Ù‚ØµØ© Ù…Ù† Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù„ØºÙˆÙŠ.");
                    console.error("LLM response structure unexpected:", parsedData);
                }
            } else {
                setError("Ù„Ù… ÙŠØ±Ø¬Ø¹ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù„ØºÙˆÙŠ Ù…Ø­ØªÙˆÙ‰ ØµØ§Ù„Ø­Ù‹Ø§.");
                console.error("LLM response missing candidates:", result);
            }
        } catch (err) {
            console.error("Error generating story:", err);
            setError(`Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù‚ØµØ©: ${err.message}`);
            setIsPlaying(false);
        } finally {
            setIsLoading(false);
        }
    }, []);

    // Function to advance to the next scene
    const advanceScene = useCallback(() => {
        setCurrentSceneIndex(prevIndex => {
            const nextIndex = prevIndex + 1;
            if (nextIndex >= storyScenes.length) {
                setIsPlaying(false); // Stop playing when done
                return prevIndex; // Stay on the last scene
            }
            return nextIndex;
        });
        setSceneProgress(0); // Reset progress for the new scene
    }, [storyScenes.length]);

    // Effect to control the simulated video playback and progress bar
    useEffect(() => {
        // Clear any existing intervals and animation frames
        if (sceneIntervalRef.current) {
            clearInterval(sceneIntervalRef.current);
        }
        if (progressAnimationRef.current) {
            cancelAnimationFrame(progressAnimationRef.current);
        }

        if (isPlaying && storyScenes.length > 0) {
            // Set up interval for scene changes
            sceneIntervalRef.current = setInterval(advanceScene, SCENE_DURATION_MS);

            // Set up animation frame for smooth progress bar updates
            lastTimestampRef.current = performance.now();
            const animateProgress = (timestamp) => {
                const elapsed = timestamp - lastTimestampRef.current;
                setSceneProgress(prevProgress => {
                    const newProgress = prevProgress + (elapsed / SCENE_DURATION_MS) * 100;
                    return Math.min(newProgress, 100); // Cap at 100%
                });
                lastTimestampRef.current = timestamp;

                if (isPlaying) { // Only continue animating if still playing
                    progressAnimationRef.current = requestAnimationFrame(animateProgress);
                }
            };
            progressAnimationRef.current = requestAnimationFrame(animateProgress);
        }

        // Cleanup function: clear interval and animation frame when component unmounts or playing stops
        return () => {
            if (sceneIntervalRef.current) {
                clearInterval(sceneIntervalRef.current);
            }
            if (progressAnimationRef.current) {
                cancelAnimationFrame(progressAnimationRef.current);
            }
        };
    }, [isPlaying, storyScenes, advanceScene]);

    // Function to handle play/pause toggle
    const togglePlayPause = () => {
        if (storyScenes.length > 0) {
            setIsPlaying(prev => !prev);
        }
    };

    // Function to restart the "video" from the beginning
    const restartVideo = () => {
        setCurrentSceneIndex(0);
        setSceneProgress(0); // Reset progress
        setIsPlaying(true);
    };

    // Function to download the full story text
    const downloadStoryText = () => {
        if (storyScenes.length === 0) {
            setError("Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚ØµØ© Ù„ØªÙ†Ø²ÙŠÙ„Ù‡Ø§ Ø¨Ø¹Ø¯.");
            return;
        }
        const fullStory = storyScenes.map(scene => scene.text).join('\n\n');
        const blob = new Blob([fullStory], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'Ù‚ØµØ©_Ø£Ø·ÙØ§Ù„_Ø®Ø§ØµØ©_Ø¨Ùƒ.txt';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    };

    // Function to download the current scene as an image
    const downloadCurrentSceneImage = () => {
        if (!currentScene) {
            setError("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø´Ù‡Ø¯ Ù„Ø¹Ø±Ø¶Ù‡ Ø£Ùˆ ØªÙ†Ø²ÙŠÙ„Ù‡.");
            return;
        }

        // Create a temporary canvas to draw the scene content
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Define canvas dimensions
        const padding = 40;
        const emojiSize = 120; // Size for emoji
        const textSize = 24;   // Font size for text
        const textLineHeight = 36;
        const maxWidth = 500; // Max width for content

        // Calculate text wrapping for width
        const words = currentScene.text.split(' ');
        let line = '';
        const lines = [];
        ctx.font = `${textSize}px 'Inter', sans-serif`;
        ctx.textAlign = 'right'; // For Arabic text

        for (let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            const metrics = ctx.measureText(testLine);
            const testWidth = metrics.width;
            if (testWidth > maxWidth - padding * 2 && n > 0) {
                lines.push(line);
                line = words[n] + ' ';
            } else {
                line = testLine;
            }
        }
        lines.push(line);

        const textHeight = lines.length * textLineHeight;
        const totalHeight = emojiSize + textHeight + padding * 3; // Emoji + text + padding

        canvas.width = maxWidth;
        canvas.height = totalHeight;

        // Fill background
        ctx.fillStyle = '#E0F2F7'; // Light blue background
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw visual hint (emoji)
        ctx.font = `${emojiSize}px 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(renderVisualHint(currentScene.visualHint), canvas.width / 2, padding + emojiSize / 2);

        // Draw text
        ctx.font = `${textSize}px 'Inter', sans-serif`;
        ctx.fillStyle = '#4B5563'; // Dark gray text
        ctx.textAlign = 'right'; // For Arabic text
        let y = padding * 2 + emojiSize;
        for (let i = 0; i < lines.length; i++) {
            ctx.fillText(lines[i], canvas.width - padding, y);
            y += textLineHeight;
        }

        // Convert canvas to image data URL
        const dataURL = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = dataURL;
        link.download = `Ù…Ø´Ù‡Ø¯_Ø§Ù„Ù‚ØµØ©_${currentSceneIndex + 1}.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setError(null); // Clear any previous error
    };


    // Current scene to display
    const currentScene = storyScenes[currentSceneIndex];
    // Calculate total duration for overall progress bar
    const totalDurationSeconds = storyScenes.length * SCENE_DURATION_SECONDS;
    const currentVideoTimeSeconds = currentSceneIndex * SCENE_DURATION_SECONDS + (sceneProgress / 100) * SCENE_DURATION_SECONDS;
    const overallProgress = (currentVideoTimeSeconds / totalDurationSeconds) * 100;

    // Helper to render emojis or SVG for visual hints
    const renderVisualHint = (hint) => {
        // A more robust mapping for common story elements or
        // simple SVG rendering could be added here.
        // For now, mapping some keywords to emojis.
        if (!hint) return 'âœ¨'; // Default if no hint

        if (hint.includes('Ø£Ø±Ù†Ø¨')) return 'ğŸ°';
        if (hint.includes('Ø­Ù‚Ù„') || hint.includes('Ø­Ø¯ÙŠÙ‚Ø©')) return 'ğŸŒ³';
        if (hint.includes('ØªÙ„') || hint.includes('Ø¬Ø¨Ù„')) return 'ğŸï¸';
        if (hint.includes('Ø«Ø¹Ù„Ø¨')) return 'ğŸ¦Š';
        if (hint.includes('Ø¨ÙŠØª') || hint.includes('Ù…Ù†Ø²Ù„')) return 'ğŸ¡';
        if (hint.includes('Ø´Ù…Ø³') || hint.includes('Ù…Ø´Ø±Ù‚Ø©')) return 'â˜€ï¸';
        if (hint.includes('Ù†Ù‡Ø±') || hint.includes('Ù…Ø§Ø¡')) return 'ğŸ’§';
        if (hint.includes('Ø²Ù‡ÙˆØ±') || hint.includes('Ø²Ù‡Ø±Ø©')) return 'ğŸŒ»';
        if (hint.includes('Ù‚ÙˆØ³ Ù‚Ø²Ø­')) return 'ğŸŒˆ';
        if (hint.includes('Ø³Ø­Ø§Ø¨Ø©')) return 'â˜ï¸';
        if (hint.includes('Ù†Ø¬ÙˆÙ…')) return 'ğŸŒŸ';
        if (hint.includes('Ø£Ø«Ø±') || hint.includes('Ø®Ø·Ù‰')) return 'ğŸ¾';
        if (hint.includes('Ø·Ø§Ø¦Ø±')) return 'ğŸ¦';
        if (hint.includes('Ø£Ø´Ø¬Ø§Ø±')) return 'ğŸŒ²';
        if (hint.includes('ÙØ±Ø§Ø´Ø©')) return 'ğŸ¦‹';
        if (hint.includes('Ù‚Ù…Ø±')) return 'ğŸŒ™';
        if (hint.includes('Ù…ØºØ§Ù…Ø±Ø©')) return 'ğŸ—ºï¸';
        // Fallback if no specific emoji match
        return hint.split(' ')[0] || 'âœ¨'; // Just take the first word or default
    };


    return (
        <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-purple-100 to-blue-200 p-4 font-sans text-gray-800">
            {/* Tailwind CSS and Inter font import */}
            <style>
                {`
                @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
                body {
                    font-family: 'Inter', sans-serif;
                }
                .button-shadow {
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
                }
                .button-hover:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1);
                }
                .button-active:active {
                    transform: translateY(0);
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
                }
                .scene-content {
                    opacity: 1;
                    transition: opacity 1s ease-in-out;
                }
                .scene-content.fade-out {
                    opacity: 0;
                }
                `}
            </style>

            <div className="bg-white rounded-xl shadow-2xl p-8 max-w-2xl w-full text-center border-4 border-indigo-300">
                <h1 className="text-4xl font-bold text-indigo-700 mb-4 animate-bounce-y">
                    Ù†Ø¸Ø§Ù… ØµØ§Ù†Ø¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ø§Ù„Ù‚ØµØµÙŠØ© <br/> Ù„Ù„Ø£Ø·ÙØ§Ù„ ğŸš€
                </h1>

                <p className="text-gray-600 mb-6">
                    Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø£ÙŠÙ‡Ø§ Ø§Ù„Ù…Ø³ØªÙƒØ´Ù! Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø§Ù„Ø³Ø­Ø±ÙŠ Ù„ØªÙˆÙ„ÙŠØ¯ Ù‚ØµØ© Ø£Ø·ÙØ§Ù„ ÙØ±ÙŠØ¯Ø© Ù…Ù† Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ØŒ ÙˆØ´Ø§Ù‡Ø¯Ù‡Ø§ ØªØªØ­ÙˆÙ„ Ø¥Ù„Ù‰ "ÙÙŠØ¯ÙŠÙˆ" Ø¨Ø¶ØºØ·Ø© Ø²Ø±.
                </p>

                <button
                    onClick={generateStoryVideo}
                    disabled={isLoading}
                    className={`
                        bg-gradient-to-r from-green-500 to-emerald-600 text-white font-bold py-3 px-8 rounded-full text-xl
                        transition-all duration-300 ease-in-out button-shadow button-hover button-active
                        ${isLoading ? 'opacity-70 cursor-not-allowed' : ''}
                    `}
                >
                    {isLoading ? (
                        <div className="flex items-center justify-center">
                            <svg className="animate-spin -ml-1 mr-3 h-6 w-6 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙˆÙ„ÙŠØ¯...
                        </div>
                    ) : (
                        'ØªÙˆÙ„ÙŠØ¯ ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ù‚ØµØ© Ø§Ù„Ø¢Ù†!'
                    )}
                </button>

                {error && (
                    <div className="mt-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg" role="alert">
                        <p className="font-bold">Ø®Ø·Ø£!</p>
                        <p>{error}</p>
                    </div>
                )}

                {storyScenes.length > 0 && (
                    <div className="mt-8 bg-blue-50 p-6 rounded-xl shadow-inner text-lg text-right overflow-hidden relative min-h-[350px] flex flex-col justify-center items-center border border-blue-200">
                        <h2 className="text-2xl font-semibold text-blue-700 mb-4">
                            Ù…Ø´Ø§Ù‡Ø¯ Ø§Ù„Ù‚ØµØ©:
                        </h2>
                        {currentScene && (
                            <div ref={sceneContentRef} className="scene-content transition-opacity duration-1000 ease-in-out bg-blue-50 p-4 rounded-lg w-full">
                                <div className="text-7xl mb-4 flex justify-center items-center h-32">
                                    {renderVisualHint(currentScene.visualHint)}
                                </div>
                                <p className="text-gray-700 leading-relaxed min-h-[100px] text-justify px-4">
                                    {currentScene.text}
                                </p>
                            </div>
                        )}

                        {/* Progress Bar for current scene */}
                        <div className="w-full bg-gray-200 rounded-full h-2.5 mt-4">
                            <div
                                className="bg-gradient-to-r from-blue-400 to-indigo-500 h-2.5 rounded-full transition-all duration-100 ease-linear"
                                style={{ width: `${sceneProgress}%` }}
                            ></div>
                        </div>

                        {/* Video Controls */}
                        <div className="flex justify-center gap-4 mt-6 w-full flex-wrap">
                            <button
                                onClick={togglePlayPause}
                                className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-5 rounded-full text-lg flex items-center button-shadow button-hover"
                            >
                                {isPlaying ? (
                                    <>
                                        <svg className="h-6 w-6 mr-2" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd"></path></svg>
                                        Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª
                                    </>
                                ) : (
                                    <>
                                 
