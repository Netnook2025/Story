import React, { useState, useEffect, useRef, useCallback } from 'react';

// Main App component
const App = () => {
    // State to store the story scenes (text and visual hints)
    const [storyScenes, setStoryScenes] = useState([]);
    // State to track the current scene being displayed
    const [currentSceneIndex, setCurrentSceneIndex] = useState(0);
    // State to manage loading status during story generation
    const [isLoading, setIsLoading] = useState(false);
    // State to control video playback (simulated)
    const [isPlaying, setIsPlaying] = useState(false);
    // State to store any error messages
    const [error, setError] = useState(null);
    // State for scene progression bar
    const [sceneProgress, setSceneProgress] = useState(0);

    // Ref for the interval timer to control scene progression
    const sceneIntervalRef = useRef(null);
    // Ref for the progress bar animation frame
    const progressAnimationRef = useRef(null);
    // Ref for the last timestamp for progress bar animation
    const lastTimestampRef = useRef(0);
    // Ref for the scene content element to capture as image
    const sceneContentRef = useRef(null);

    // Constants for scene duration
    const SCENE_DURATION_SECONDS = 5; // Each scene lasts 5 seconds
    const SCENE_DURATION_MS = SCENE_DURATION_SECONDS * 1000; // 5000 milliseconds

    // Function to generate the story and visual hints using the LLM
    const generateStoryVideo = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        setStoryScenes([]); // Clear previous story
        setCurrentSceneIndex(0); // Reset scene index
        setSceneProgress(0); // Reset progress
        setIsPlaying(false); // Stop playing initially

        // LLM prompt to generate a children's story with visual hints in JSON format
        const prompt = `
        إنشاء قصة أطفال قصيرة (3-5 دقائق عند القراءة بصوت عالٍ) حول حيوان ودود يذهب في مغامرة صغيرة لاكتشاف شيء جديد.
        يجب أن تكون القصة مقسمة إلى 5-7 فقرات.
        لكل فقرة، اقترح تلميحًا مرئيًا بسيطًا (مثل: 'صورة لأرنب يلعب في حديقة' أو 'رسوم متحركة لثعلب يخطط' أو 'رمز تعبيري لشمس مشرقة').
        يجب أن يمكن تمثيل الـ 'visualHint' برموز تعبيرية أو رسوم SVG بسيطة جداً، أو وصف نصي واضح.
        قم بتنسيق الإخراج ككائن JSON، حيث يكون كل عنصر في مصفوفة 'scenes' عبارة عن كائن يحتوي على 'text' (نص الفقرة) و 'visualHint' (تلميح مرئي).
        مثال للتنسيق:
        {
          "scenes": [
            {
              "text": "كان هناك أرنب صغير يدعى باني، يعيش في حقل أخضر واسع.",
              "visualHint": "🐰 حقل أخضر واسع"
            },
            {
              "text": "في أحد الأيام، قرر باني استكشاف ما وراء التل الكبير.",
              "visualHint": "🏞️ أرنب يستكشف تلاً"
            }
          ]
        }
        `;

        try {
            const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = {
                contents: chatHistory,
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "scenes": {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        "text": { "type": "STRING" },
                                        "visualHint": { "type": "STRING" }
                                    },
                                    "propertyOrdering": ["text", "visualHint"]
                                }
                            }
                        },
                        "propertyOrdering": ["scenes"]
                    }
                }
            };

            const apiKey = ""; // Canvas will provide this.
            // Using the correct model for JSON generation as per instructions
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API request failed: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
            }

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                const jsonText = result.candidates[0].content.parts[0].text;
                const parsedData = JSON.parse(jsonText);
                if (parsedData && parsedData.scenes && Array.isArray(parsedData.scenes)) {
                    setStoryScenes(parsedData.scenes);
                    setIsPlaying(true); // Start playing immediately after generation
                } else {
                    setError("فشل في تحليل مشاهد القصة من استجابة النموذج اللغوي.");
                    console.error("LLM response structure unexpected:", parsedData);
                }
            } else {
                setError("لم يرجع النموذج اللغوي محتوى صالحًا.");
                console.error("LLM response missing candidates:", result);
            }
        } catch (err) {
            console.error("Error generating story:", err);
            setError(`حدث خطأ أثناء توليد القصة: ${err.message}`);
            setIsPlaying(false);
        } finally {
            setIsLoading(false);
        }
    }, []);

    // Function to advance to the next scene
    const advanceScene = useCallback(() => {
        setCurrentSceneIndex(prevIndex => {
            const nextIndex = prevIndex + 1;
            if (nextIndex >= storyScenes.length) {
                setIsPlaying(false); // Stop playing when done
                return prevIndex; // Stay on the last scene
            }
            return nextIndex;
        });
        setSceneProgress(0); // Reset progress for the new scene
    }, [storyScenes.length]);

    // Effect to control the simulated video playback and progress bar
    useEffect(() => {
        // Clear any existing intervals and animation frames
        if (sceneIntervalRef.current) {
            clearInterval(sceneIntervalRef.current);
        }
        if (progressAnimationRef.current) {
            cancelAnimationFrame(progressAnimationRef.current);
        }

        if (isPlaying && storyScenes.length > 0) {
            // Set up interval for scene changes
            sceneIntervalRef.current = setInterval(advanceScene, SCENE_DURATION_MS);

            // Set up animation frame for smooth progress bar updates
            lastTimestampRef.current = performance.now();
            const animateProgress = (timestamp) => {
                const elapsed = timestamp - lastTimestampRef.current;
                setSceneProgress(prevProgress => {
                    const newProgress = prevProgress + (elapsed / SCENE_DURATION_MS) * 100;
                    return Math.min(newProgress, 100); // Cap at 100%
                });
                lastTimestampRef.current = timestamp;

                if (isPlaying) { // Only continue animating if still playing
                    progressAnimationRef.current = requestAnimationFrame(animateProgress);
                }
            };
            progressAnimationRef.current = requestAnimationFrame(animateProgress);
        }

        // Cleanup function: clear interval and animation frame when component unmounts or playing stops
        return () => {
            if (sceneIntervalRef.current) {
                clearInterval(sceneIntervalRef.current);
            }
            if (progressAnimationRef.current) {
                cancelAnimationFrame(progressAnimationRef.current);
            }
        };
    }, [isPlaying, storyScenes, advanceScene]);

    // Function to handle play/pause toggle
    const togglePlayPause = () => {
        if (storyScenes.length > 0) {
            setIsPlaying(prev => !prev);
        }
    };

    // Function to restart the "video" from the beginning
    const restartVideo = () => {
        setCurrentSceneIndex(0);
        setSceneProgress(0); // Reset progress
        setIsPlaying(true);
    };

    // Function to download the full story text
    const downloadStoryText = () => {
        if (storyScenes.length === 0) {
            setError("لا توجد قصة لتنزيلها بعد.");
            return;
        }
        const fullStory = storyScenes.map(scene => scene.text).join('\n\n');
        const blob = new Blob([fullStory], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'قصة_أطفال_خاصة_بك.txt';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    };

    // Function to download the current scene as an image
    const downloadCurrentSceneImage = () => {
        if (!currentScene) {
            setError("لا يوجد مشهد لعرضه أو تنزيله.");
            return;
        }

        // Create a temporary canvas to draw the scene content
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Define canvas dimensions
        const padding = 40;
        const emojiSize = 120; // Size for emoji
        const textSize = 24;   // Font size for text
        const textLineHeight = 36;
        const maxWidth = 500; // Max width for content

        // Calculate text wrapping for width
        const words = currentScene.text.split(' ');
        let line = '';
        const lines = [];
        ctx.font = `${textSize}px 'Inter', sans-serif`;
        ctx.textAlign = 'right'; // For Arabic text

        for (let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            const metrics = ctx.measureText(testLine);
            const testWidth = metrics.width;
            if (testWidth > maxWidth - padding * 2 && n > 0) {
                lines.push(line);
                line = words[n] + ' ';
            } else {
                line = testLine;
            }
        }
        lines.push(line);

        const textHeight = lines.length * textLineHeight;
        const totalHeight = emojiSize + textHeight + padding * 3; // Emoji + text + padding

        canvas.width = maxWidth;
        canvas.height = totalHeight;

        // Fill background
        ctx.fillStyle = '#E0F2F7'; // Light blue background
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw visual hint (emoji)
        ctx.font = `${emojiSize}px 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(renderVisualHint(currentScene.visualHint), canvas.width / 2, padding + emojiSize / 2);

        // Draw text
        ctx.font = `${textSize}px 'Inter', sans-serif`;
        ctx.fillStyle = '#4B5563'; // Dark gray text
        ctx.textAlign = 'right'; // For Arabic text
        let y = padding * 2 + emojiSize;
        for (let i = 0; i < lines.length; i++) {
            ctx.fillText(lines[i], canvas.width - padding, y);
            y += textLineHeight;
        }

        // Convert canvas to image data URL
        const dataURL = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = dataURL;
        link.download = `مشهد_القصة_${currentSceneIndex + 1}.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setError(null); // Clear any previous error
    };


    // Current scene to display
    const currentScene = storyScenes[currentSceneIndex];
    // Calculate total duration for overall progress bar
    const totalDurationSeconds = storyScenes.length * SCENE_DURATION_SECONDS;
    const currentVideoTimeSeconds = currentSceneIndex * SCENE_DURATION_SECONDS + (sceneProgress / 100) * SCENE_DURATION_SECONDS;
    const overallProgress = (currentVideoTimeSeconds / totalDurationSeconds) * 100;

    // Helper to render emojis or SVG for visual hints
    const renderVisualHint = (hint) => {
        // A more robust mapping for common story elements or
        // simple SVG rendering could be added here.
        // For now, mapping some keywords to emojis.
        if (!hint) return '✨'; // Default if no hint

        if (hint.includes('أرنب')) return '🐰';
        if (hint.includes('حقل') || hint.includes('حديقة')) return '🌳';
        if (hint.includes('تل') || hint.includes('جبل')) return '🏞️';
        if (hint.includes('ثعلب')) return '🦊';
        if (hint.includes('بيت') || hint.includes('منزل')) return '🏡';
        if (hint.includes('شمس') || hint.includes('مشرقة')) return '☀️';
        if (hint.includes('نهر') || hint.includes('ماء')) return '💧';
        if (hint.includes('زهور') || hint.includes('زهرة')) return '🌻';
        if (hint.includes('قوس قزح')) return '🌈';
        if (hint.includes('سحابة')) return '☁️';
        if (hint.includes('نجوم')) return '🌟';
        if (hint.includes('أثر') || hint.includes('خطى')) return '🐾';
        if (hint.includes('طائر')) return '🐦';
        if (hint.includes('أشجار')) return '🌲';
        if (hint.includes('فراشة')) return '🦋';
        if (hint.includes('قمر')) return '🌙';
        if (hint.includes('مغامرة')) return '🗺️';
        // Fallback if no specific emoji match
        return hint.split(' ')[0] || '✨'; // Just take the first word or default
    };


    return (
        <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-purple-100 to-blue-200 p-4 font-sans text-gray-800">
            {/* Tailwind CSS and Inter font import */}
            <style>
                {`
                @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
                body {
                    font-family: 'Inter', sans-serif;
                }
                .button-shadow {
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
                }
                .button-hover:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1);
                }
                .button-active:active {
                    transform: translateY(0);
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
                }
                .scene-content {
                    opacity: 1;
                    transition: opacity 1s ease-in-out;
                }
                .scene-content.fade-out {
                    opacity: 0;
                }
                `}
            </style>

            <div className="bg-white rounded-xl shadow-2xl p-8 max-w-2xl w-full text-center border-4 border-indigo-300">
                <h1 className="text-4xl font-bold text-indigo-700 mb-4 animate-bounce-y">
                    نظام صانع الفيديوهات القصصية <br/> للأطفال 🚀
                </h1>

                <p className="text-gray-600 mb-6">
                    مرحباً أيها المستكشف! اضغط على الزر السحري لتوليد قصة أطفال فريدة من المستقبل، وشاهدها تتحول إلى "فيديو" بضغطة زر.
                </p>

                <button
                    onClick={generateStoryVideo}
                    disabled={isLoading}
                    className={`
                        bg-gradient-to-r from-green-500 to-emerald-600 text-white font-bold py-3 px-8 rounded-full text-xl
                        transition-all duration-300 ease-in-out button-shadow button-hover button-active
                        ${isLoading ? 'opacity-70 cursor-not-allowed' : ''}
                    `}
                >
                    {isLoading ? (
                        <div className="flex items-center justify-center">
                            <svg className="animate-spin -ml-1 mr-3 h-6 w-6 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            جاري التوليد...
                        </div>
                    ) : (
                        'توليد فيديو القصة الآن!'
                    )}
                </button>

                {error && (
                    <div className="mt-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg" role="alert">
                        <p className="font-bold">خطأ!</p>
                        <p>{error}</p>
                    </div>
                )}

                {storyScenes.length > 0 && (
                    <div className="mt-8 bg-blue-50 p-6 rounded-xl shadow-inner text-lg text-right overflow-hidden relative min-h-[350px] flex flex-col justify-center items-center border border-blue-200">
                        <h2 className="text-2xl font-semibold text-blue-700 mb-4">
                            مشاهد القصة:
                        </h2>
                        {currentScene && (
                            <div ref={sceneContentRef} className="scene-content transition-opacity duration-1000 ease-in-out bg-blue-50 p-4 rounded-lg w-full">
                                <div className="text-7xl mb-4 flex justify-center items-center h-32">
                                    {renderVisualHint(currentScene.visualHint)}
                                </div>
                                <p className="text-gray-700 leading-relaxed min-h-[100px] text-justify px-4">
                                    {currentScene.text}
                                </p>
                            </div>
                        )}

                        {/* Progress Bar for current scene */}
                        <div className="w-full bg-gray-200 rounded-full h-2.5 mt-4">
                            <div
                                className="bg-gradient-to-r from-blue-400 to-indigo-500 h-2.5 rounded-full transition-all duration-100 ease-linear"
                                style={{ width: `${sceneProgress}%` }}
                            ></div>
                        </div>

                        {/* Video Controls */}
                        <div className="flex justify-center gap-4 mt-6 w-full flex-wrap">
                            <button
                                onClick={togglePlayPause}
                                className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-5 rounded-full text-lg flex items-center button-shadow button-hover"
                            >
                                {isPlaying ? (
                                    <>
                                        <svg className="h-6 w-6 mr-2" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd"></path></svg>
                                        إيقاف مؤقت
                                    </>
                                ) : (
                                    <>
                                 
