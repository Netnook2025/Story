<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ØµØ§Ù†Ø¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ø§Ù„Ù‚ØµØµÙŠØ© Ù„Ù„Ø£Ø·ÙØ§Ù„</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        .button-shadow {
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
        }
        .button-hover:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .button-active:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-purple-100 to-blue-200 min-h-screen flex items-center justify-center p-4">

    <div id="root"></div>

    <script type="module">
        import React, { useState, useEffect, useRef, useCallback } from 'https://esm.sh/react@18.2.0';
        import ReactDOM from 'https://esm.sh/react-dom@18.2.0/client';
        
        // Helper function to create a root for React rendering
        function createRoot() {
            const rootElement = document.getElementById('root');
            if (rootElement) {
                return ReactDOM.createRoot(rootElement);
            }
            return null;
        }

        const App = () => {
            const [storyScenes, setStoryScenes] = useState([]);
            const [currentSceneIndex, setCurrentSceneIndex] = useState(0);
            const [isLoading, setIsLoading] = useState(false);
            const [isPlaying, setIsPlaying] = useState(false);
            const [error, setError] = useState(null);
            const [sceneProgress, setSceneProgress] = useState(0);

            const sceneIntervalRef = useRef(null);
            const progressAnimationRef = useRef(null);
            const lastTimestampRef = useRef(0);

            const SCENE_DURATION_SECONDS = 5;
            const SCENE_DURATION_MS = SCENE_DURATION_SECONDS * 1000;

            const generateStoryVideo = useCallback(async () => {
                setIsLoading(true);
                setError(null);
                setStoryScenes([]);
                setCurrentSceneIndex(0);
                setSceneProgress(0);
                setIsPlaying(false);

                const prompt = `
                Ø¥Ù†Ø´Ø§Ø¡ Ù‚ØµØ© Ø£Ø·ÙØ§Ù„ Ù‚ØµÙŠØ±Ø© (3-5 Ø¯Ù‚Ø§Ø¦Ù‚ Ø¹Ù†Ø¯ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© Ø¨ØµÙˆØª Ø¹Ø§Ù„Ù) Ø­ÙˆÙ„ Ø­ÙŠÙˆØ§Ù† ÙˆØ¯ÙˆØ¯ ÙŠØ°Ù‡Ø¨ ÙÙŠ Ù…ØºØ§Ù…Ø±Ø© ØµØºÙŠØ±Ø© Ù„Ø§ÙƒØªØ´Ø§Ù Ø´ÙŠØ¡ Ø¬Ø¯ÙŠØ¯.
                ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ù‚ØµØ© Ù…Ù‚Ø³Ù…Ø© Ø¥Ù„Ù‰ 5-7 ÙÙ‚Ø±Ø§Øª.
                Ù„ÙƒÙ„ ÙÙ‚Ø±Ø©ØŒ Ø§Ù‚ØªØ±Ø­ ØªÙ„Ù…ÙŠØ­Ù‹Ø§ Ù…Ø±Ø¦ÙŠÙ‹Ø§ Ø¨Ø³ÙŠØ·Ù‹Ø§ (Ù…Ø«Ù„: 'ØµÙˆØ±Ø© Ù„Ø£Ø±Ù†Ø¨ ÙŠÙ„Ø¹Ø¨ ÙÙŠ Ø­Ø¯ÙŠÙ‚Ø©' Ø£Ùˆ 'Ø±Ø³ÙˆÙ… Ù…ØªØ­Ø±ÙƒØ© Ù„Ø«Ø¹Ù„Ø¨ ÙŠØ®Ø·Ø·' Ø£Ùˆ 'Ø±Ù…Ø² ØªØ¹Ø¨ÙŠØ±ÙŠ Ù„Ø´Ù…Ø³ Ù…Ø´Ø±Ù‚Ø©').
                ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙ…ÙƒÙ† ØªÙ…Ø«ÙŠÙ„ Ø§Ù„Ù€ 'visualHint' Ø¨Ø±Ù…ÙˆØ² ØªØ¹Ø¨ÙŠØ±ÙŠØ© Ø£Ùˆ Ø±Ø³ÙˆÙ… SVG Ø¨Ø³ÙŠØ·Ø© Ø¬Ø¯Ø§Ù‹ØŒ Ø£Ùˆ ÙˆØµÙ Ù†ØµÙŠ ÙˆØ§Ø¶Ø­.
                Ù‚Ù… Ø¨ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ ÙƒÙƒØ§Ø¦Ù† JSONØŒ Ø­ÙŠØ« ÙŠÙƒÙˆÙ† ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ Ù…ØµÙÙˆÙØ© 'scenes' Ø¹Ø¨Ø§Ø±Ø© Ø¹Ù† ÙƒØ§Ø¦Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ 'text' (Ù†Øµ Ø§Ù„ÙÙ‚Ø±Ø©) Ùˆ 'visualHint' (ØªÙ„Ù…ÙŠØ­ Ù…Ø±Ø¦ÙŠ).
                Ù…Ø«Ø§Ù„ Ù„Ù„ØªÙ†Ø³ÙŠÙ‚:
                {
                  "scenes": [
                    {
                      "text": "ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø£Ø±Ù†Ø¨ ØµØºÙŠØ± ÙŠØ¯Ø¹Ù‰ Ø¨Ø§Ù†ÙŠØŒ ÙŠØ¹ÙŠØ´ ÙÙŠ Ø­Ù‚Ù„ Ø£Ø®Ø¶Ø± ÙˆØ§Ø³Ø¹.",
                      "visualHint": "ğŸ° Ø­Ù‚Ù„ Ø£Ø®Ø¶Ø± ÙˆØ§Ø³Ø¹"
                    },
                    {
                      "text": "ÙÙŠ Ø£Ø­Ø¯ Ø§Ù„Ø£ÙŠØ§Ù…ØŒ Ù‚Ø±Ø± Ø¨Ø§Ù†ÙŠ Ø§Ø³ØªÙƒØ´Ø§Ù Ù…Ø§ ÙˆØ±Ø§Ø¡ Ø§Ù„ØªÙ„ Ø§Ù„ÙƒØ¨ÙŠØ±.",
                      "visualHint": "ğŸï¸ Ø£Ø±Ù†Ø¨ ÙŠØ³ØªÙƒØ´Ù ØªÙ„Ø§Ù‹"
                    }
                  ]
                }
                `;

                try {
                    const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                    const payload = {
                        contents: chatHistory,
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "OBJECT",
                                properties: {
                                    "scenes": {
                                        type: "ARRAY",
                                        items: {
                                            type: "OBJECT",
                                            properties: {
                                                "text": { "type": "STRING" },
                                                "visualHint": { "type": "STRING" }
                                            },
                                            "propertyOrdering": ["text", "visualHint"]
                                        }
                                    }
                                },
                                "propertyOrdering": ["scenes"]
                            }
                        }
                    };

                    const apiKey = "";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API request failed: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
                    }

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const jsonText = result.candidates[0].content.parts[0].text;
                        const parsedData = JSON.parse(jsonText);
                        if (parsedData && parsedData.scenes && Array.isArray(parsedData.scenes)) {
                            setStoryScenes(parsedData.scenes);
                            setIsPlaying(true);
                        } else {
                            setError("ÙØ´Ù„ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ù…Ø´Ø§Ù‡Ø¯ Ø§Ù„Ù‚ØµØ© Ù…Ù† Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù„ØºÙˆÙŠ.");
                            console.error("LLM response structure unexpected:", parsedData);
                        }
                    } else {
                        setError("Ù„Ù… ÙŠØ±Ø¬Ø¹ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù„ØºÙˆÙŠ Ù…Ø­ØªÙˆÙ‰ ØµØ§Ù„Ø­Ù‹Ø§.");
                        console.error("LLM response missing candidates:", result);
                    }
                } catch (err) {
                    console.error("Error generating story:", err);
                    setError(`Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù‚ØµØ©: ${err.message}`);
                    setIsPlaying(false);
                } finally {
                    setIsLoading(false);
                }
            }, []);

            const advanceScene = useCallback(() => {
                setCurrentSceneIndex(prevIndex => {
                    const nextIndex = prevIndex + 1;
                    if (nextIndex >= storyScenes.length) {
                        setIsPlaying(false);
                        return prevIndex;
                    }
                    return nextIndex;
                });
                setSceneProgress(0);
            }, [storyScenes.length]);

            useEffect(() => {
                if (sceneIntervalRef.current) {
                    clearInterval(sceneIntervalRef.current);
                }
                if (progressAnimationRef.current) {
                    cancelAnimationFrame(progressAnimationRef.current);
                }

                if (isPlaying && storyScenes.length > 0) {
                    sceneIntervalRef.current = setInterval(advanceScene, SCENE_DURATION_MS);
                    lastTimestampRef.current = performance.now();
                    const animateProgress = (timestamp) => {
                        const elapsed = timestamp - lastTimestampRef.current;
                        setSceneProgress(prevProgress => {
                            const newProgress = prevProgress + (elapsed / SCENE_DURATION_MS) * 100;
                            return Math.min(newProgress, 100);
                        });
                        lastTimestampRef.current = timestamp;

                        if (isPlaying) {
                            progressAnimationRef.current = requestAnimationFrame(animateProgress);
                        }
                    };
                    progressAnimationRef.current = requestAnimationFrame(animateProgress);
                }

                return () => {
                    if (sceneIntervalRef.current) {
                        clearInterval(sceneIntervalRef.current);
                    }
                    if (progressAnimationRef.current) {
                        cancelAnimationFrame(progressAnimationRef.current);
                    }
                };
            }, [isPlaying, storyScenes, advanceScene]);

            const togglePlayPause = () => {
                if (storyScenes.length > 0) {
                    setIsPlaying(prev => !prev);
                }
            };

            const restartVideo = () => {
                setCurrentSceneIndex(0);
                setSceneProgress(0);
                setIsPlaying(true);
            };

            const downloadStoryText = () => {
                if (storyScenes.length === 0) {
                    setError("Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚ØµØ© Ù„ØªÙ†Ø²ÙŠÙ„Ù‡Ø§ Ø¨Ø¹Ø¯.");
                    return;
                }
                const fullStory = storyScenes.map(scene => scene.text).join('\n\n');
                const blob = new Blob([fullStory], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'Ù‚ØµØ©_Ø£Ø·ÙØ§Ù„_Ø®Ø§ØµØ©_Ø¨Ùƒ.txt';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            };

            const downloadCurrentSceneImage = () => {
                const currentScene = storyScenes[currentSceneIndex];
                if (!currentScene) {
                    setError("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø´Ù‡Ø¯ Ù„Ø¹Ø±Ø¶Ù‡ Ø£Ùˆ ØªÙ†Ø²ÙŠÙ„Ù‡.");
                    return;
                }

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const padding = 40;
                const emojiSize = 120;
                const textSize = 24;
                const textLineHeight = 36;
                const maxWidth = 500;

                const words = currentScene.text.split(' ');
                let line = '';
                const lines = [];
                ctx.font = `${textSize}px 'Inter', sans-serif`;
                ctx.textAlign = 'right';

                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = ctx.measureText(testLine);
                    const testWidth = metrics.width;
                    if (testWidth > maxWidth - padding * 2 && n > 0) {
                        lines.push(line);
                        line = words[n] + ' ';
                    } else {
                        line = testLine;
                    }
                }
                lines.push(line);

                const textHeight = lines.length * textLineHeight;
                const totalHeight = emojiSize + textHeight + padding * 3;

                canvas.width = maxWidth;
                canvas.height = totalHeight;

                ctx.fillStyle = '#E0F2F7';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.font = `${emojiSize}px 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(renderVisualHint(currentScene.visualHint), canvas.width / 2, padding + emojiSize / 2);

                ctx.font = `${textSize}px 'Inter', sans-serif`;
                ctx.fillStyle = '#4B5563';
                ctx.textAlign = 'right';
                let y = padding * 2 + emojiSize;
                for (let i = 0; i < lines.length; i++) {
                    ctx.fillText(lines[i], canvas.width - padding, y);
                    y += textLineHeight;
                }

                const dataURL = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = `Ù…Ø´Ù‡Ø¯_Ø§Ù„Ù‚ØµØ©_${currentSceneIndex + 1}.png`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                setError(null);
            };

            const renderVisualHint = (hint) => {
                if (!hint) return 'âœ¨';
                if (hint.includes('Ø£Ø±Ù†Ø¨')) return 'ğŸ°';
                if (hint.includes('Ø­Ù‚Ù„') || hint.includes('Ø­Ø¯ÙŠÙ‚Ø©')) return 'ğŸŒ³';
                if (hint.includes('ØªÙ„') || hint.includes('Ø¬Ø¨Ù„')) return 'ğŸï¸';
                if (hint.includes('Ø«Ø¹Ù„Ø¨')) return 'ğŸ¦Š';
                if (hint.includes('Ø¨ÙŠØª') || hint.includes('Ù…Ù†Ø²Ù„')) return 'ğŸ¡';
                if (hint.includes('Ø´Ù…Ø³') || hint.includes('Ù…Ø´Ø±Ù‚Ø©')) return 'â˜€ï¸';
                if (hint.includes('Ù†Ù‡Ø±') || hint.includes('Ù…Ø§Ø¡')) return 'ğŸ’§';
                if (hint.includes('Ø²Ù‡ÙˆØ±') || hint.includes('Ø²Ù‡Ø±Ø©')) return 'ğŸŒ»';
                if (hint.includes('Ù‚ÙˆØ³ Ù‚Ø²Ø­')) return 'ğŸŒˆ';
                if (hint.includes('Ø³Ø­Ø§Ø¨Ø©')) return 'â˜ï¸';
                if (hint.includes('Ù†Ø¬ÙˆÙ…')) return 'ğŸŒŸ';
                if (hint.includes('Ø£Ø«Ø±') || hint.includes('Ø®Ø·Ù‰')) return 'ğŸ¾';
                if (hint.includes('Ø·Ø§Ø¦Ø±')) return 'ğŸ¦';
                if (hint.includes('Ø£Ø´Ø¬Ø§Ø±')) return 'ğŸŒ²';
                if (hint.includes('ÙØ±Ø§Ø´Ø©')) return 'ğŸ¦‹';
                if (hint.includes('Ù‚Ù…Ø±')) return 'ğŸŒ™';
                if (hint.includes('Ù…ØºØ§Ù…Ø±Ø©')) return 'ğŸ—ºï¸';
                return hint.split(' ')[0] || 'âœ¨';
            };

            const currentScene = storyScenes[currentSceneIndex];
            const totalDurationSeconds = storyScenes.length * SCENE_DURATION_SECONDS;
            const currentVideoTimeSeconds = currentSceneIndex * SCENE_DURATION_SECONDS + (sceneProgress / 100) * SCENE_DURATION_SECONDS;
            const overallProgress = (currentVideoTimeSeconds / totalDurationSeconds) * 100;

            const renderSceneContent = () => {
                return currentScene ? React.createElement('div', {
                    className: "scene-content transition-opacity duration-1000 ease-in-out bg-blue-50 p-4 rounded-lg w-full"
                }, React.createElement('div', {
                    className: "text-7xl mb-4 flex justify-center items-center h-32"
                }, renderVisualHint(currentScene.visualHint)), React.createElement('p', {
                    className: "text-gray-700 leading-relaxed min-h-[100px] text-justify px-4"
                }, currentScene.text)) : null;
            };

            const renderControls = () => {
                return React.createElement('div', {
                    className: "flex justify-center gap-4 mt-6 w-full flex-wrap"
                }, React.createElement('button', {
                    onClick: togglePlayPause,
                    className: "bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-5 rounded-full text-lg flex items-center button-shadow button-hover"
                }, isPlaying ? React.createElement(React.Fragment, null, React.createElement('svg', {
                    className: "h-6 w-6 mr-2",
                    fill: "currentColor",
                    viewBox: "0 0 20 20",
                    xmlns: "http://www.w3.org/2000/svg"
                }, React.createElement('path', {
                    fillRule: "evenodd",
                    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z",
                    clipRule: "evenodd"
                })), "Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª") : React.createElement(React.Fragment, null, React.createElement('svg', {
                    className: "h-6 w-6 mr-2",
                    fill: "currentColor",
                    viewBox: "0 0 20 20",
                    xmlns: "http://www.w3.org/2000/svg"
                }, React.createElement('path', {
                    fillRule: "evenodd",
                    d: "M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z",
                    clipRule: "evenodd"
                })), "ØªØ´ØºÙŠÙ„")), React.createElement('button', {
                    onClick: restartVideo,
                    className: "bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-5 rounded-full text-lg flex items-center button-shadow button-hover"
                }, React.createElement('svg', {
                    className: "h-6 w-6 mr-2",
                    fill: "currentColor",
                    viewBox: "0 0 20 20",
                    xmlns: "http://www.w3.org/2000/svg"
                }, React.createElement('path', {
                    d: "M5 4a1 1 0 00-2 0v5a1 1 0 00.5.866l5 3a1 1 0 001-1.732L4.996 9H16a1 1 0 110 2H4.996l3.504 2.034a1 1 0 001.004-1.732l-5-3A1 1 0 005 4z",
                    clipRule: "evenodd"
                }), React.createElement('path', {
                    d: "M5 4a1 1 0 00-2 0v5a1 1 0 00.5.866l5 3a1 1 0 001-1.732L4.996 9H16a1 1 0 110 2H4.996l3.504 2.034a1 1 0 001.004-1.732l-5-3A1 1 0 005 4z",
                    clipRule: "evenodd"
                })), "Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„"), React.createElement('button', {
                    onClick: downloadStoryText,
                    className: "bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-5 rounded-full text-lg flex items-center button-shadow button-hover"
                }, React.createElement('svg', {
                    className: "h-6 w-6 mr-2",
                    fill: "currentColor",
                    viewBox: "0 0 20 20",
                    xmlns: "http://www.w3.org/2000/svg"
                }, React.createElement('path', {
                    fillRule: "evenodd",
                    d: "M4 4a2 2 0 00-2 2v8a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2H4zm0 10V6h12v8H4zm4-2a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1zm1-3a1 1 0 012 0v2a1 1 0 11-2 0V9zm-3 2a1 1 0 011-1h2a1 1 0 110 2H7a1 1 0 01-1-1z",
                    clipRule: "evenodd"
                })), "ØªÙ†Ø²ÙŠÙ„ Ø§Ù„Ù‚ØµØ©"), React.createElement('button', {
                    onClick: downloadCurrentSceneImage,
                    className: "bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-5 rounded-full text-lg flex items-center button-shadow button-hover"
                }, React.createElement('svg', {
                    className: "h-6 w-6 mr-2",
                    fill: "currentColor",
                    viewBox: "0 0 20 20",
                    xmlns: "http://www.w3.org/2000/svg"
                }, React.createElement('path', {
                    fillRule: "evenodd",
                    d: "M3 17a1 1 0 011-1h12a1 1 0 011 1v1a1 1 0 11-2 0v-1H5v1a1 1 0 11-2 0v-1zm14-5a2 2 0 00-2-2H5a2 2 0 00-2 2v2h14v-2zm-5-8a1 1 0 011-1h2a1 1 0 011 1v5a1 1 0 01-1 1h-2a1 1 0 01-1-1V4z",
                    clipRule: "evenodd"
                })), "ØªÙ†Ø²ÙŠÙ„ Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø§Ù„Ø­Ø§Ù„ÙŠ"));
            };

            const renderError = () => {
                return error ? React.createElement('div', {
                    className: "mt-6 p-4 bg-red-100 border bordne.text.split(' ');
        let line = '';
        const lines = [];
        ctx.font = `${textSize}px 'Inter', sans-serif`;
        ctx.textAlign = 'right'; // For Arabic text

        for (let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            const metrics = ctx.measureText(testLine);
            const testWidth = metrics.width;
            if (testWidth > maxWidth - padding * 2 && n > 0) {
                lines.push(line);
                line = words[n] + ' ';
            } else {
                line = testLine;
            }
        }
        lines.push(line);

        const textHeight = lines.length * textLineHeight;
        const totalHeight = emojiSize + textHeight + padding * 3; // Emoji + text + padding

        canvas.width = maxWidth;
        canvas.height = totalHeight;

        // Fill background
        ctx.fillStyle = '#E0F2F7'; // Light blue background
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw visual hint (emoji)
        ctx.font = `${emojiSize}px 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(renderVisualHint(currentScene.visualHint), canvas.width / 2, padding + emojiSize / 2);

        // Draw text
        ctx.font = `${textSize}px 'Inter', sans-serif`;
        ctx.fillStyle = '#4B5563'; // Dark gray text
        ctx.textAlign = 'right'; // For Arabic text
        let y = padding * 2 + emojiSize;
        for (let i = 0; i < lines.length; i++) {
            ctx.fillText(lines[i], canvas.width - padding, y);
            y += textLineHeight;
        }

        // Convert canvas to image data URL
        const dataURL = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = dataURL;
        link.download = `Ù…Ø´Ù‡Ø¯_Ø§Ù„Ù‚ØµØ©_${currentSceneIndex + 1}.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setError(null); // Clear any previous error
    };


    // Current scene to display
    const currentScene = storyScenes[currentSceneIndex];
    // Calculate total duration for overall progress bar
    const totalDurationSeconds = storyScenes.length * SCENE_DURATION_SECONDS;
    const currentVideoTimeSeconds = currentSceneIndex * SCENE_DURATION_SECONDS + (sceneProgress / 100) * SCENE_DURATION_SECONDS;
    const overallProgress = (currentVideoTimeSeconds / totalDurationSeconds) * 100;

    // Helper to render emojis or SVG for visual hints
    const renderVisualHint = (hint) => {
        // A more robust mapping for common story elements or
        // simple SVG rendering could be added here.
        // For now, mapping some keywords to emojis.
        if (!hint) return 'âœ¨'; // Default if no hint

        if (hint.includes('Ø£Ø±Ù†Ø¨')) return 'ğŸ°';
        if (hint.includes('Ø­Ù‚Ù„') || hint.includes('Ø­Ø¯ÙŠÙ‚Ø©')) return 'ğŸŒ³';
        if (hint.includes('ØªÙ„') || hint.includes('Ø¬Ø¨Ù„')) return 'ğŸï¸';
        if (hint.includes('Ø«Ø¹Ù„Ø¨')) return 'ğŸ¦Š';
        if (hint.includes('Ø¨ÙŠØª') || hint.includes('Ù…Ù†Ø²Ù„')) return 'ğŸ¡';
        if (hint.includes('Ø´Ù…Ø³') || hint.includes('Ù…Ø´Ø±Ù‚Ø©')) return 'â˜€ï¸';
        if (hint.includes('Ù†Ù‡Ø±') || hint.includes('Ù…Ø§Ø¡')) return 'ğŸ’§';
        if (hint.includes('Ø²Ù‡ÙˆØ±') || hint.includes('Ø²Ù‡Ø±Ø©')) return 'ğŸŒ»';
        if (hint.includes('Ù‚ÙˆØ³ Ù‚Ø²Ø­')) return 'ğŸŒˆ';
        if (hint.includes('Ø³Ø­Ø§Ø¨Ø©')) return 'â˜ï¸';
        if (hint.includes('Ù†Ø¬ÙˆÙ…')) return 'ğŸŒŸ';
        if (hint.includes('Ø£Ø«Ø±') || hint.includes('Ø®Ø·Ù‰')) return 'ğŸ¾';
        if (hint.includes('Ø·Ø§Ø¦Ø±')) return 'ğŸ¦';
        if (hint.includes('Ø£Ø´Ø¬Ø§Ø±')) return 'ğŸŒ²';
        if (hint.includes('ÙØ±Ø§Ø´Ø©')) return 'ğŸ¦‹';
        if (hint.includes('Ù‚Ù…Ø±')) return 'ğŸŒ™';
        if (hint.includes('Ù…ØºØ§Ù…Ø±Ø©')) return 'ğŸ—ºï¸';
        // Fallback if no specific emoji match
        return hint.split(' ')[0] || 'âœ¨'; // Just take the first word or default
    };


    return (
        <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-purple-100 to-blue-200 p-4 font-sans text-gray-800">
            {/* Tailwind CSS and Inter font import */}
            <style>
                {`
                @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
                body {
                    font-family: 'Inter', sans-serif;
                }
                .button-shadow {
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
                }
                .button-hover:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1);
                }
                .button-active:active {
                    transform: translateY(0);
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
                }
                .scene-content {
                    opacity: 1;
                    transition: opacity 1s ease-in-out;
                }
                .scene-content.fade-out {
                    opacity: 0;
                }
                `}
            </style>

            <div className="bg-white rounded-xl shadow-2xl p-8 max-w-2xl w-full text-center border-4 border-indigo-300">
                <h1 className="text-4xl font-bold text-indigo-700 mb-4 animate-bounce-y">
                    Ù†Ø¸Ø§Ù… ØµØ§Ù†Ø¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ø§Ù„Ù‚ØµØµÙŠØ© <br/> Ù„Ù„Ø£Ø·ÙØ§Ù„ ğŸš€
                </h1>

                <p className="text-gray-600 mb-6">
                    Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø£ÙŠÙ‡Ø§ Ø§Ù„Ù…Ø³ØªÙƒØ´Ù! Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø§Ù„Ø³Ø­Ø±ÙŠ Ù„ØªÙˆÙ„ÙŠØ¯ Ù‚ØµØ© Ø£Ø·ÙØ§Ù„ ÙØ±ÙŠØ¯Ø© Ù…Ù† Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ØŒ ÙˆØ´Ø§Ù‡Ø¯Ù‡Ø§ ØªØªØ­ÙˆÙ„ Ø¥Ù„Ù‰ "ÙÙŠØ¯ÙŠÙˆ" Ø¨Ø¶ØºØ·Ø© Ø²Ø±.
                </p>

                <button
                    onClick={generateStoryVideo}
                    disabled={isLoading}
                    className={`
                        bg-gradient-to-r from-green-500 to-emerald-600 text-white font-bold py-3 px-8 rounded-full text-xl
                        transition-all duration-300 ease-in-out button-shadow button-hover button-active
                        ${isLoading ? 'opacity-70 cursor-not-allowed' : ''}
                    `}
                >
                    {isLoading ? (
                        <div className="flex items-center justify-center">
                            <svg className="animate-spin -ml-1 mr-3 h-6 w-6 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙˆÙ„ÙŠØ¯...
                        </div>
                    ) : (
                        'ØªÙˆÙ„ÙŠØ¯ ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ù‚ØµØ© Ø§Ù„Ø¢Ù†!'
                    )}
                </button>

                {error && (
                    <div className="mt-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg" role="alert">
                        <p className="font-bold">Ø®Ø·Ø£!</p>
                        <p>{error}</p>
                    </div>
                )}

                {storyScenes.length > 0 && (
                    <div className="mt-8 bg-blue-50 p-6 rounded-xl shadow-inner text-lg text-right overflow-hidden relative min-h-[350px] flex flex-col justify-center items-center border border-blue-200">
                        <h2 className="text-2xl font-semibold text-blue-700 mb-4">
                            Ù…Ø´Ø§Ù‡Ø¯ Ø§Ù„Ù‚ØµØ©:
                        </h2>
                        {currentScene && (
                            <div ref={sceneContentRef} className="scene-content transition-opacity duration-1000 ease-in-out bg-blue-50 p-4 rounded-lg w-full">
                                <div className="text-7xl mb-4 flex justify-center items-center h-32">
                                    {renderVisualHint(currentScene.visualHint)}
                                </div>
                                <p className="text-gray-700 leading-relaxed min-h-[100px] text-justify px-4">
                                    {currentScene.text}
                                </p>
                            </div>
                        )}

                        {/* Progress Bar for current scene */}
                        <div className="w-full bg-gray-200 rounded-full h-2.5 mt-4">
                            <div
                                className="bg-gradient-to-r from-blue-400 to-indigo-500 h-2.5 rounded-full transition-all duration-100 ease-linear"
                                style={{ width: `${sceneProgress}%` }}
                            ></div>
                        </div>

                        {/* Video Controls */}
                        <div className="flex justify-center gap-4 mt-6 w-full flex-wrap">
                            <button
                                onClick={togglePlayPause}
                                className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-5 rounded-full text-lg flex items-center button-shadow button-hover"
                            >
                                {isPlaying ? (
                                    <>
                                        <svg className="h-6 w-6 mr-2" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd"></path></svg>
                                        Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª
                                    </>
                                ) : (
                                    <>
                                 
